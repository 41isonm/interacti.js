{"version":3,"file":"annotorious-core.es.js","sources":["../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/src/runtime/internal/utils.js","../../../node_modules/svelte/src/runtime/store/index.js","../src/state/Hover.ts","../src/state/Selection.ts","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../src/utils/annotationUtils.ts","../src/utils/diffAnnotations.ts","../src/state/StoreObserver.ts","../src/state/Store.ts","../src/state/SvelteStore.ts","../../../node_modules/nanoevents/index.js","../src/state/UndoStack.ts","../src/state/Viewport.ts","../src/lifecycle/Lifecycle.ts","../src/model/FormatAdapter.ts","../src/model/Annotator.ts","../../../node_modules/nanoid/url-alphabet/index.js","../../../node_modules/nanoid/index.browser.js","../src/model/User.ts","../src/model/W3CAnnotation.ts","../src/presence/ColorPalette.ts","../src/presence/AppearanceProvider.ts","../src/presence/PresenceState.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string | undefined>();\n\n  let currentHover: string | undefined;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = (changes.deleted || []).some(a => a.id === currentHover);\n      if (isDeleted)\n        set(undefined);\n    \n      const updated = (changes.updated || []).find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport { dequal } from 'dequal/lite';\n\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport interface Selection {\n\n  selected: { id: string, editable?: boolean }[],\n\n  event?: PointerEvent | KeyboardEvent;\n\n  [key: string]: any; // Allow for additional properties to be added by plugins\n\n}\n\nexport type SelectionState<T extends Annotation> = ReturnType<typeof createSelectionState<T>>;\n\nexport enum UserSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n\n  SELECT = 'SELECT',  // Just select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - annotation is completely inert\n\n}\n\nexport type UserSelectActionExpression<T extends Annotation> = UserSelectAction | ((a: T) => UserSelectAction);\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <T extends Annotation>(\n  store: Store<T>,\n  defaultSelectionAction?: UserSelectActionExpression<T>\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentUserSelectAction = defaultSelectionAction;\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => {\n    if (!dequal(currentSelection, EMPTY)) {\n      set(EMPTY);\n    }\n  };\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: T | string) => {\n    if (isEmpty())\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  // TODO enable CTRL select\n  const userSelect = (id: string, event?: Selection['event']) => {\n    const annotation = store.getAnnotation(id);\n    if (!annotation) {\n      console.warn('Invalid selection: ' + id);\n      return;\n    }\n\n    const action = onUserSelect(annotation, currentUserSelectAction);\n    switch (action) {\n      case UserSelectAction.EDIT:\n        set({ selected: [{ id, editable: true }], event });\n        break;\n      case UserSelectAction.SELECT:\n        set({ selected: [{ id }], event });\n        break;\n      default:\n        set({ selected: [], event });\n    }\n  }\n\n  const setSelected = (idOrIds: string | string[], editable?: boolean) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = ids\n      .map(id => store.getAnnotation(id))\n      .filter((a): a is T => Boolean(a));\n\n    set({\n      selected: annotations.map(annotation => {\n        // If editable is not set, use default behavior\n        const isEditable = editable === undefined\n          ? onUserSelect(annotation, currentUserSelectAction) === UserSelectAction.EDIT\n          : editable;\n\n        return { id: annotation.id, editable: isEditable }\n      })\n    });\n\n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (isEmpty())\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const shouldRemove = selected.some(({ id }) => ids.includes(id));\n    if (shouldRemove)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<T> | undefined) =>\n    currentUserSelectAction = action;\n\n  // Track store delete and update events\n  store.observe(\n    ({ changes }) => removeFromSelection((changes.deleted || []).map(a => a.id))\n  );\n\n  return {\n    get event() {\n      return currentSelection ? currentSelection.event : null;\n    },\n    get selected() {\n      return currentSelection ? [...currentSelection.selected] : null;\n    },\n    get userSelectAction() {\n      return currentUserSelectAction;\n    },\n    clear,\n    isEmpty,\n    isSelected,\n    setSelected,\n    setUserSelectAction,\n    subscribe,\n    userSelect\n  };\n\n}\n\nexport const onUserSelect = <T extends Annotation>(\n  annotation: T,\n  action?: UserSelectActionExpression<T>\n): UserSelectAction => (typeof action === 'function') ? action(annotation) : (action || UserSelectAction.EDIT);\n","import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  var uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}","var randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody } from '../model/Annotation';\nimport type {  User } from '../model/User';\n\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy].filter(Boolean) as User[]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u) as User[] // Remove undefined\n}\n\ntype HasTime = { created?: string | Date; updated?: string | Date; };\n\n/** \n * Converts any string dates in the given annotation(-like) \n * object to proper Date objects.\n */\nexport const reviveDates = <A extends Annotation>(annotation: A): A => {\n\n  const revive = <T extends HasTime>(body: T): T => {\n    const revived = {...body};\n\n    if (body.created && typeof body.created === 'string')\n      revived.created = new Date(body.created);\n\n    if (body.updated && typeof body.updated === 'string')\n      revived.updated = new Date(body.updated);\n\n    return revived;\n  }\n\n  return {\n    ...annotation,\n    bodies: (annotation.bodies || []).map(revive),\n    target: revive(annotation.target)\n  }\n}\n\n/**\n * Shorthand/helper.\n */\nexport const createBody = (\n  annotationOrId: string | Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state/StoreObserver';\nimport type { Annotation } from '../model/Annotation';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody)\n    .map(({ oldBody, newBody }) => ({ oldBody: oldBody!, newBody }));\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => {\n  const bodiesCreated = getAddedBodies(oldValue, newValue);\n  const bodiesDeleted = getRemovedBodies(oldValue, newValue);\n  const bodiesUpdated = getChangedBodies(oldValue, newValue);\n\n  return {\n    oldValue, \n    newValue,\n    bodiesCreated: bodiesCreated.length > 0 ? bodiesCreated : undefined,\n    bodiesDeleted: bodiesDeleted.length > 0 ? bodiesDeleted : undefined,\n    bodiesUpdated: bodiesUpdated.length > 0 ? bodiesUpdated : undefined,\n    targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model/Annotation';\nimport { diffAnnotations } from '../utils';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: AnnotationBody[];\n\n  bodiesDeleted?: AnnotationBody[];\n\n  bodiesUpdated?: Array<{ oldBody: AnnotationBody, newBody: AnnotationBody }>;\n\n  targetUpdated?: { oldTarget: AnnotationTarget, newTarget: AnnotationTarget};\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** \n * Allows the observer to listen only for events that originated locally or from a remote source.\n * \n * SILENT should be used for updates that are not supposed to trigger an event. Remember that \n * with great power comes great responsibility: SILENT is really for Annotorious plugins and\n * extensions ONLY.\n */\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE',\n  \n  SILENT = 'SILENT'\n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = observer.options.origin \n    ? observer.options.origin === origin \n    : origin !== Origin.SILENT;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[] | undefined) => arg && arg.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...(changes.created || []).map(a => a.id),\n      ...(changes.deleted || []).map(a => a.id),\n      ...(changes.updated || []).map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(changes: ChangeSet<T>, toMerge: ChangeSet<T>) => {\n  const previouslyCreatedIds = new Set((changes.created || []).map(a => a.id));\n  const previouslyUpdatedIds = new Set((changes.updated || []).map(({ newValue })=> newValue.id));\n\n  const createdIds = new Set((toMerge.created || []).map(a => a.id));\n  const deletedIds = new Set((toMerge.deleted || []).map(a => a.id));\n  const updatedIds = new Set((toMerge.updated || []).map(({ oldValue }) => oldValue.id));\n\n  // Updates that will be merged into create or previous update events\n  const mergeableUpdates = new Set((toMerge.updated || [])\n    .filter(({ oldValue }) => previouslyCreatedIds.has(oldValue.id) || previouslyUpdatedIds.has(oldValue.id))\n    .map(({ oldValue }) => oldValue.id ));\n\n  // * created *\n  // - drop created that were then deleted\n  // - merge any updates on created\n  // - append newly created\n  const created = [\n    ...(changes.created || [])\n      .filter(a => !deletedIds.has(a.id))\n      .map(a => updatedIds.has(a.id) \n        ? toMerge.updated!.find(({ oldValue }) => oldValue.id === a.id)!.newValue\n        : a),\n    ...(toMerge.created || [])\n  ];\n\n  // * deleted *\n  // - drop deleted that were later re-created (redo action!)\n  // - append newly deleted, but remove any that delete annotations \n  //   that were created in the same round\n  const deleted = [\n    ...(changes.deleted || [])\n      .filter(a => !createdIds.has(a.id)),\n    ...(toMerge.deleted || []) \n      .filter(a => !previouslyCreatedIds.has(a.id))\n  ] \n\n  // * updated *\n  // - drop updates on deleted annotations\n  // - merge any updates that override previous ones\n  // - append new updates, but remove any that were merged\n  const updated = [\n    ...(changes.updated || [])\n      .filter(({ newValue }) => !deletedIds.has(newValue.id))\n      .map(update => {\n        const { oldValue, newValue } = update;\n        if (updatedIds.has(newValue.id)) {\n          const updated = toMerge.updated!.find(u => u.oldValue.id === newValue.id)!.newValue;\n          return diffAnnotations(oldValue, updated);\n        } else {\n          return update;\n        }\n      }),\n    ...(toMerge.updated || []).filter(({ oldValue }) => !mergeableUpdates.has(oldValue.id))\n  ]\n\n  return { created, deleted, updated };\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nconst sanitize = <T extends Annotation>(a: Partial<T>): T => {\n  const id = a.id === undefined ? uuidv4() : a.id;\n\n  return {\n    ...a,\n    id,\n    bodies: a.bodies === undefined ? [] : a.bodies.map(b => ({\n      ...b,\n      annotation: id \n    })),\n    target: {\n      ...a.target,\n      annotation: id\n    }\n  } as T;\n}\n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) => {\n    observers.push({ onChange, options });\n  }\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: Partial<T>, origin = Origin.LOCAL) => {\n    const existing = annotation.id && annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      const sanitized = sanitize(annotation);\n\n      annotationIndex.set(sanitized.id, sanitized);\n      sanitized.bodies.forEach(b => bodyIndex.set(b.id, sanitized.id));\n      emit(origin, { created: [sanitized] });\n    }\n  }\n\n  const updateOneAnnotation = (arg1: string | Partial<T>, arg2?: Partial<T> | Origin) => {\n    const updated: T = typeof arg1 === 'string' ? sanitize(arg2 as Partial<T>) : sanitize(arg1);\n\n    const oldId: string | undefined = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = oldId && annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      return update;\n    } else {\n      console.warn(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n  \n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const update = updateOneAnnotation(arg1, arg2);\n    if (update)\n      emit(origin, { updated: [update] })\n  }\n\n  const bulkUpdateAnnotation = (annotations: T[], origin = Origin.LOCAL) => {\n    const updated = annotations.reduce((updated, annotation) => {\n      const u = updateOneAnnotation(annotation);\n      return u ? [...updated, u] : updated;\n    }, [] as Update<T>[]);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const addBody = (body: T['bodies'][number], origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotation = (annotations: Partial<T>[], replace = true, origin = Origin.LOCAL) => {\n    const sanitized = annotations.map(sanitize);\n\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = next.id && annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, [] as T[]);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotation = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n\n  const deleteOneBody = (body: AnnotationBodyIdentifier) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        return update;\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const updated = deleteOneBody(body);\n    if (updated)\n      emit(origin, { updated: [ updated  ]});\n  }\n\n  const bulkDeleteBodies = (bodies: AnnotationBodyIdentifier[], origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => deleteOneBody(b)!)\n      .filter(Boolean);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): T['bodies'][number] | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation!.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number]) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id)!;\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number], origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: Array<T['bodies'][number]>, origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b)!)\n      .filter(Boolean);\n\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: T['target']): Update<T> | undefined => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: T['target'], origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: Array<T['target']>, origin = Origin.LOCAL) => {\n    const updated = \n      targets.map(t => updateOneTarget(t)!).filter(Boolean);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotation,\n    bulkDeleteAnnotation,\n    bulkDeleteBodies,\n    bulkUpdateAnnotation,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget\n\t};\n\n}\n","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<T extends Annotation> extends AnnotatorState<T> {\n\n  store: SvelteStore<T>\n\n}\n\nexport interface SvelteAnnotator<T extends Annotation> extends Annotator<T> {\n\n  state: SvelteAnnotatorState<T>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation = Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    for (\n      let i = 0,\n        callbacks = this.events[event] || [],\n        length = callbacks.length;\n      i < length;\n      i++\n    ) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    ;(this.events[event] ||= []).push(cb)\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\nimport { Origin } from './StoreObserver';\nimport { mergeChanges, type ChangeSet, type StoreChangeEvent, type Update } from './StoreObserver';\n\n// Duration with fast successive changes get merged \n// with the last event in the stack, rather than getting stacked\n// as a new undo/redo step.\nconst DEBOUNCE = 250;\n\nexport interface UndoStack <T extends Annotation> {\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  destroy(): void;\n\n  on<E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]): Unsubscribe;\n\n  undo(): void;\n\n  redo(): void;\n\n}\n\nexport interface UndoStackEvents <T extends Annotation> {\n\n  redo(change: ChangeSet<T>): void;\n\n  undo(change: ChangeSet<T>): void;\n\n}\n\nexport const createUndoStack = <T extends Annotation>(store: Store<T>): UndoStack<T> => {\n\n  const emitter = createNanoEvents<UndoStackEvents<T>>();\n\n  const changeStack: ChangeSet<T>[] = [];\n\n  let pointer = -1;\n\n  let muteEvents = false;\n\n  let lastEvent = 0;\n\n  const onChange = (event: StoreChangeEvent<T>) => {\n    if (!muteEvents) {\n      const { changes } = event;\n\n      const now = performance.now();\n\n      if (now - lastEvent > DEBOUNCE) {\n        // Put this change on the stack...\n        changeStack.splice(pointer + 1);\n        changeStack.push(changes);\n\n        // ...and update the pointer\n        pointer = changeStack.length - 1;\n      } else {\n        // Merge this change with the last in the stack\n        const last = changeStack.length - 1;\n        changeStack[last] = mergeChanges(changeStack[last], changes);\n      }\n\n      lastEvent = now;\n    }\n\n    muteEvents = false;\n  }\n\n  store.observe(onChange, { origin: Origin.LOCAL });\n\n  const undoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkDeleteAnnotation(created);\n\n  const redoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkAddAnnotation(created, false);\n\n  const undoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ oldValue }) => oldValue));\n      \n  const redoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ newValue }) => newValue));\n\n  const undoDeleted = (deleted?: T[]) => \n    deleted && deleted.length > 0 && store.bulkAddAnnotation(deleted, false);\n\n  const redoDeleted = (deleted?: T[]) =>\n    deleted && deleted.length > 0 && store.bulkDeleteAnnotation(deleted);\n\n  const undo = () => {\n    if (pointer > -1) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer];\n\n      undoCreated(created);\n      undoUpdated(updated);\n      undoDeleted(deleted);\n\n      emitter.emit('undo', changeStack[pointer]);\n\n      pointer -= 1;\n    }\n  }\n\n  const canUndo = () => pointer > -1;\n\n  const redo = () => {\n    if (changeStack.length - 1 > pointer) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer + 1];\n\n      redoCreated(created);\n      redoUpdated(updated);\n      redoDeleted(deleted);\n\n      emitter.emit('redo', changeStack[pointer + 1]);\n\n      pointer += 1;\n    }\n  }\n\n  const canRedo = () => changeStack.length - 1 > pointer;\n\n  const destroy = () => store.unobserve(onChange);\n\n  const on = <E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]) => \n    emitter.on(event, callback);\n\n  return {\n    canRedo,\n    canUndo,\n    destroy,\n    on,\n    redo,\n    undo\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, AnnotatorState, FormatAdapter } from '../model';\nimport { Origin, type ChangeSet, type UndoStack } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecycleObserver<I, E>>;\n\nexport const createLifecycleObserver = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>,\n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const { store, selection, hover, viewport } = state;\n\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event)!.push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx !== -1)\n        callbacks.splice(idx, 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event)!.forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selection;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = (selected || []).map(({ id }) => store.getAnnotation(id)!);\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selection.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id)!);\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected\n          .filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id)!)\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hover.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    }\n\n    currentHover = id;\n  });\n\n  viewport?.subscribe(ids => \n    emit('viewportIntersect', ids.map(id => store.getAnnotation(id)!)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    (created || []).forEach(a => emit('createAnnotation', a));\n    (deleted || []).forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = (event.changes.updated || []).filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = (event.changes.updated || [])\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  const onUndoOrRedo = (undo: boolean) => (changes: ChangeSet<I>) => {\n    // Undo/redo of created/delete will cause lifecycle events automatically,\n    // but we need to handle updates specifically!\n    const { updated } = changes;\n\n    if (undo)\n      (updated || []).forEach(t => emit('updateAnnotation', t.oldValue, t.newValue));\n    else\n      (updated || []).forEach(t => emit('updateAnnotation', t.newValue, t.oldValue));\n  }\n\n  undoStack.on('undo', onUndoOrRedo(true));\n  undoStack.on('redo', onUndoOrRedo(false));\n\n  return { on, off, emit }\n\n}\n","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  parseAll?(serialized: unknown[]): { parsed: A[], failed: T[] };\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n      \n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : parsed ? {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      } : {\n        ...result\n      }\n    }, { parsed: [] as A[], failed: [] as T[]});\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence';\nimport type {\n  HoverState,\n  SelectionState,\n  Store,\n  UndoStack,\n  UserSelectActionExpression,\n  ViewportState\n} from '../state';\nimport { Origin } from '../state';\nimport type { LifecycleEvents } from '../lifecycle';\nimport { reviveDates } from '../utils';\nimport { type FormatAdapter, parseAll } from './FormatAdapter';\nimport type { DrawingStyleExpression } from './DrawingStyle';\nimport type { Filter } from './Filter';\n\n/**\n * Base annotator interface\n * @template I - internal core data model\n * @template E - external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  addAnnotation(annotation: Partial<E>): void;\n\n  cancelSelected(): void;\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getSelected(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string, replace?: boolean): Promise<E[]>;\n\n  redo(): void;\n\n  removeAnnotation(arg: Partial<E> | string): E | undefined;\n\n  setAnnotations(annotations: Partial<E>[], replace?: boolean): void;\n\n  setFilter(filter: Filter | undefined): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[], editable?: boolean): void;\n\n  setStyle(style: DrawingStyleExpression<I> | undefined): void;\n\n  setUser(user: User): void;\n\n  setUserSelectAction(action: UserSelectActionExpression<I>): void;\n\n  setVisible(visible: boolean): void;\n\n  undo(): void;\n\n  updateAnnotation(annotation: Partial<E>): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I>;\n\n}\n\nexport interface AnnotatorState<A extends Annotation> {\n\n  store: Store<A>;\n\n  selection: SelectionState<A>;\n\n  hover: HoverState<A>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>, \n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const { store, selection } = state;\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(reviveDates(annotation as unknown as I), Origin.REMOTE);\n    }\n  }\n\n  const cancelSelected = () => selection.clear();\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const getSelected = () => {\n    const selectedIds = selection.selected?.map(s => s.id) || [];\n\n    const selected = selectedIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n    return adapter \n      ? selected.map(adapter.serialize) \n      : selected as unknown as E[];\n  }\n\n  const loadAnnotations = (url: string, replace = true) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations, replace);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E | undefined => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      if (annotation)\n        return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n\n      if (annotation) {\n        store.deleteAnnotation(annotation);\n        return arg;\n      }\n    }\n  }\n\n  const setAnnotations = (annotations: E[], replace = true) => {\n    if (adapter) {\n      const parseFn = adapter.parseAll || parseAll(adapter);\n      const { parsed, failed } = parseFn(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotation(parsed, replace, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotation((annotations as unknown as I[]).map(reviveDates), replace, Origin.REMOTE);\n    }\n  }\n\n  const setSelected = (arg?: string | string[], editable?: boolean) => {\n    if (arg) {\n      selection.setSelected(arg, editable);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<I>) => {\n    selection.clear();\n    selection.setUserSelectAction(action);\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed!;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id)!);\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(reviveDates(updated as unknown as I));\n      return previous as unknown as E;\n    }\n  }\n\n  // Note that we don't spread the undoStack - it has a .destroy()\n  // method that would likely get overwritten by other Annotator implementations\n  // if people are not careful.\n  return { \n    addAnnotation,\n    cancelSelected,\n    canRedo: undoStack.canRedo,\n    canUndo: undoStack.canUndo,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    getSelected,\n    loadAnnotations,\n    redo: undoStack.redo,\n    removeAnnotation,\n    setAnnotations,\n    setSelected,\n    setUserSelectAction,\n    undo: undoStack.undo,\n    updateAnnotation\n  }\n\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[];\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CUser {\n\n  type?: string;\n\n  id: string;\n\n  name?: string;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  type?: string;\n\n  id?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  id?: string;\n\n  source: string;\n\n  selector?: AbstractW3CSelector;\n\n}\n\nexport interface AbstractW3CSelector { }\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    let chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\nexport const parseW3CUser = (user?: any) => user\n  ? typeof user === 'object' ? { ...user } : user : undefined;\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[],\n  annotationId: string\n) : AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Extract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, modified, creator, ...rest } = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || `temp-${hashCode(body)}`,\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    creator: parseW3CUser(creator),\n    created: created ? new Date(created) : undefined,\n    updated: modified ? new Date(modified) : undefined,\n    ...rest\n  }\n\n});\n\n/** Serialization helper to remove core-specific fields from the annotation body **/\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] =>\n  bodies.map(b => {\n    const { annotation: _a, created, updated, ...bodyRest } = b;\n\n    const w3cBody: W3CAnnotationBody =  {\n      ...bodyRest,\n      created: created?.toISOString(),\n      modified: updated?.toISOString()\n    }\n    if (w3cBody.id?.startsWith('temp-')) {\n      delete w3cBody.id;\n    }\n\n    return w3cBody;\n  });\n","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model/User';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearanceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model/User';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearanceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearanceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}"],"names":["has","dequal","foo","bar","ctor","len","noop","safe_not_equal","a","b","subscriber_queue","writable","value","start","stop","subscribers","set","new_value","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","createHoverState","store","currentHover","updated","changes","oldValue","UserSelectAction","EMPTY","createSelectionState","defaultSelectionAction","currentUserSelectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","userSelect","event","annotation","onUserSelect","setSelected","idOrIds","editable","ids","annotations","isEditable","removeFromSelection","selected","setUserSelectAction","action","byteToHex","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","v4","options","buf","rnds","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","reviveDates","revive","revived","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","bodiesCreated","bodiesDeleted","bodiesUpdated","Ignore","Origin","shouldNotify","observer","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","mergeChanges","toMerge","previouslyCreatedIds","previouslyUpdatedIds","createdIds","deletedIds","updatedIds","mergeableUpdates","deleted","sanitize","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","sanitized","updateOneAnnotation","arg1","arg2","oldId","updateAnnotation","arg3","bulkUpdateAnnotation","addBody","all","bulkAddAnnotation","replace","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotation","annotationsOrIds","deleteOneBody","oldAnnotation","newAnnotation","deleteBody","bulkDeleteBodies","bodies","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","updateOneTarget","target","targets","t","toSvelteStore","shim","createNanoEvents","args","callbacks","length","cb","DEBOUNCE","createUndoStack","emitter","changeStack","pointer","muteEvents","lastEvent","now","last","undoCreated","redoCreated","undoUpdated","redoUpdated","undoDeleted","redoDeleted","callback","createViewportState","createLifecycleObserver","state","undoStack","adapter","autoSave","selection","hover","viewport","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","onUndoOrRedo","undo","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","cancelSelected","clearAnnotations","getAnnotationById","getAnnotations","getSelected","s","loadAnnotations","url","response","setAnnotations","removeAnnotation","parseFn","failed","crosswalked","previous","urlAlphabet","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","j","customAlphabet","nanoid","scopedUrlAlphabet","createAnonymousGuest","hashCode","obj","str","hash","chr","parseW3CUser","user","parseW3CBodies","type","purpose","modified","rest","serializeW3CBodies","bodyRest","w3cBody","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearanceProvider","colorProvider","presenceKey","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","keys","toAdd","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","from"],"mappings":"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","x_google_ignoreList":[0,1,2,5,6,7,8,14,20,21]}