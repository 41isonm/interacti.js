import { Annotation } from '../model';
import { Store } from './Store';
export interface Selection {
    selected: {
        id: string;
        editable?: boolean;
    }[];
    event?: PointerEvent | KeyboardEvent;
    [key: string]: any;
}
export type SelectionState<T extends Annotation> = ReturnType<typeof createSelectionState<T>>;
export declare enum UserSelectAction {
    EDIT = "EDIT",// Make annotation target(s) editable on pointer select
    SELECT = "SELECT",// Just select, but don't make editable
    NONE = "NONE"
}
export type UserSelectActionExpression<T extends Annotation> = UserSelectAction | ((a: T) => UserSelectAction);
export declare const createSelectionState: <T extends Annotation>(store: Store<T>, defaultSelectionAction?: UserSelectActionExpression<T>) => {
    readonly event: PointerEvent | KeyboardEvent | null | undefined;
    readonly selected: {
        id: string;
        editable?: boolean;
    }[] | null;
    readonly userSelectAction: UserSelectActionExpression<T> | undefined;
    clear: () => void;
    isEmpty: () => boolean;
    isSelected: (annotationOrId: T | string) => boolean;
    setSelected: (idOrIds: string | string[], editable?: boolean) => void;
    setUserSelectAction: (action: UserSelectActionExpression<T> | undefined) => UserSelectActionExpression<T> | undefined;
    subscribe: (this: void, run: import('svelte/store').Subscriber<Selection>, invalidate?: import('svelte/store').Invalidator<Selection> | undefined) => import('svelte/store').Unsubscriber;
    userSelect: (id: string, event?: Selection["event"]) => void;
};
export declare const onUserSelect: <T extends Annotation>(annotation: T, action?: UserSelectActionExpression<T>) => UserSelectAction;
//# sourceMappingURL=Selection.d.ts.map