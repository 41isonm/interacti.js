var q = Object.prototype.hasOwnProperty;
function I(e, n) {
  var t, o;
  if (e === n) return !0;
  if (e && n && (t = e.constructor) === n.constructor) {
    if (t === Date) return e.getTime() === n.getTime();
    if (t === RegExp) return e.toString() === n.toString();
    if (t === Array) {
      if ((o = e.length) === n.length)
        for (; o-- && I(e[o], n[o]); ) ;
      return o === -1;
    }
    if (!t || typeof e == "object") {
      o = 0;
      for (t in e)
        if (q.call(e, t) && ++o && !q.call(n, t) || !(t in n) || !I(e[t], n[t])) return !1;
      return Object.keys(n).length === o;
    }
  }
  return e !== e && n !== n;
}
function _() {
}
function X(e, n) {
  return e != e ? n == n : e !== n || e && typeof e == "object" || typeof e == "function";
}
const k = [];
function M(e, n = _) {
  let t;
  const o = /* @__PURE__ */ new Set();
  function i(b) {
    if (X(e, b) && (e = b, t)) {
      const w = !k.length;
      for (const g of o)
        g[1](), k.push(g, e);
      if (w) {
        for (let g = 0; g < k.length; g += 2)
          k[g][0](k[g + 1]);
        k.length = 0;
      }
    }
  }
  function f(b) {
    i(b(e));
  }
  function y(b, w = _) {
    const g = [b, w];
    return o.add(g), o.size === 1 && (t = n(i, f) || _), b(e), () => {
      o.delete(g), o.size === 0 && t && (t(), t = null);
    };
  }
  return { set: i, update: f, subscribe: y };
}
const Ue = (e) => {
  const { subscribe: n, set: t } = M();
  let o;
  return n((i) => o = i), e.observe(({ changes: i }) => {
    if (o) {
      (i.deleted || []).some((b) => b.id === o) && t(void 0);
      const y = (i.updated || []).find(({ oldValue: b }) => b.id === o);
      y && t(y.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: n,
    set: t
  };
};
var Z = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(Z || {});
const z = { selected: [] }, Te = (e, n) => {
  const { subscribe: t, set: o } = M(z);
  let i = n, f = z;
  t((A) => f = A);
  const y = () => {
    I(f, z) || o(z);
  }, b = () => {
    var A;
    return ((A = f.selected) == null ? void 0 : A.length) === 0;
  }, w = (A) => {
    if (b())
      return !1;
    const v = typeof A == "string" ? A : A.id;
    return f.selected.some((L) => L.id === v);
  }, g = (A, v) => {
    const L = e.getAnnotation(A);
    if (!L) {
      console.warn("Invalid selection: " + A);
      return;
    }
    switch (G(L, i)) {
      case "EDIT":
        o({ selected: [{ id: A, editable: !0 }], event: v });
        break;
      case "SELECT":
        o({ selected: [{ id: A }], event: v });
        break;
      default:
        o({ selected: [], event: v });
    }
  }, S = (A, v) => {
    const L = Array.isArray(A) ? A : [A], O = L.map((a) => e.getAnnotation(a)).filter((a) => !!a);
    o({
      selected: O.map((a) => {
        const u = v === void 0 ? G(a, i) === "EDIT" : v;
        return { id: a.id, editable: u };
      })
    }), O.length !== L.length && console.warn("Invalid selection", A);
  }, r = (A) => {
    if (b())
      return !1;
    const { selected: v } = f;
    v.some(({ id: O }) => A.includes(O)) && o({ selected: v.filter(({ id: O }) => !A.includes(O)) });
  }, E = (A) => i = A;
  return e.observe(
    ({ changes: A }) => r((A.deleted || []).map((v) => v.id))
  ), {
    get event() {
      return f ? f.event : null;
    },
    get selected() {
      return f ? [...f.selected] : null;
    },
    get userSelectAction() {
      return i;
    },
    clear: y,
    isEmpty: b,
    isSelected: w,
    setSelected: S,
    setUserSelectAction: E,
    subscribe: t,
    userSelect: g
  };
}, G = (e, n) => typeof n == "function" ? n(e) : n || "EDIT";
var D = [];
for (var Y = 0; Y < 256; ++Y)
  D.push((Y + 256).toString(16).slice(1));
function K(e, n = 0) {
  return (D[e[n + 0]] + D[e[n + 1]] + D[e[n + 2]] + D[e[n + 3]] + "-" + D[e[n + 4]] + D[e[n + 5]] + "-" + D[e[n + 6]] + D[e[n + 7]] + "-" + D[e[n + 8]] + D[e[n + 9]] + "-" + D[e[n + 10]] + D[e[n + 11]] + D[e[n + 12]] + D[e[n + 13]] + D[e[n + 14]] + D[e[n + 15]]).toLowerCase();
}
var $, ee = new Uint8Array(16);
function te() {
  if (!$ && ($ = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !$))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return $(ee);
}
var ne = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const H = {
  randomUUID: ne
};
function F(e, n, t) {
  if (H.randomUUID && !n && !e)
    return H.randomUUID();
  e = e || {};
  var o = e.random || (e.rng || te)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, K(o);
}
const Oe = (e) => {
  const { creator: n, updatedBy: t } = e.target, o = e.bodies.reduce((i, f) => [...i, f.creator, f.updatedBy].filter(Boolean), []);
  return [
    n,
    t,
    ...o
  ].filter((i) => i);
}, j = (e) => {
  const n = (t) => {
    const o = { ...t };
    return t.created && typeof t.created == "string" && (o.created = new Date(t.created)), t.updated && typeof t.updated == "string" && (o.updated = new Date(t.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(n),
    target: n(e.target)
  };
}, De = (e, n, t, o) => ({
  id: F(),
  annotation: typeof e == "string" ? e : e.id,
  created: t || /* @__PURE__ */ new Date(),
  creator: o,
  ...n
}), oe = (e, n) => {
  const t = new Set(e.bodies.map((o) => o.id));
  return n.bodies.filter((o) => !t.has(o.id));
}, se = (e, n) => {
  const t = new Set(n.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !t.has(o.id));
}, ie = (e, n) => n.bodies.map((t) => {
  const o = e.bodies.find((i) => i.id === t.id);
  return { newBody: t, oldBody: o && !I(o, t) ? o : void 0 };
}).filter(({ oldBody: t }) => t).map(({ oldBody: t, newBody: o }) => ({ oldBody: t, newBody: o })), de = (e, n) => !I(e.target, n.target), J = (e, n) => {
  const t = oe(e, n), o = se(e, n), i = ie(e, n);
  return {
    oldValue: e,
    newValue: n,
    bodiesCreated: t.length > 0 ? t : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: i.length > 0 ? i : void 0,
    targetUpdated: de(e, n) ? { oldTarget: e.target, newTarget: n.target } : void 0
  };
};
var ae = /* @__PURE__ */ ((e) => (e.BODY_ONLY = "BODY_ONLY", e.TARGET_ONLY = "TARGET_ONLY", e))(ae || {}), T = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(T || {});
const re = (e, n) => {
  var f, y;
  const { changes: t, origin: o } = n;
  if (!(e.options.origin ? e.options.origin === o : o !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: b } = e.options, w = (S) => S && S.length > 0;
    if (!(w(t.created) || w(t.deleted))) {
      const S = (f = t.updated) == null ? void 0 : f.some((E) => w(E.bodiesCreated) || w(E.bodiesDeleted) || w(E.bodiesUpdated)), r = (y = t.updated) == null ? void 0 : y.some((E) => E.targetUpdated);
      if (b === "BODY_ONLY" && S && !r || b === "TARGET_ONLY" && r && !S)
        return !1;
    }
  }
  if (e.options.annotations) {
    const b = /* @__PURE__ */ new Set([
      ...(t.created || []).map((g) => g.id),
      ...(t.deleted || []).map((g) => g.id),
      ...(t.updated || []).map(({ oldValue: g }) => g.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((g) => b.has(g));
  } else
    return !0;
}, ce = (e, n) => {
  const t = new Set((e.created || []).map((r) => r.id)), o = new Set((e.updated || []).map(({ newValue: r }) => r.id)), i = new Set((n.created || []).map((r) => r.id)), f = new Set((n.deleted || []).map((r) => r.id)), y = new Set((n.updated || []).map(({ oldValue: r }) => r.id)), b = new Set((n.updated || []).filter(({ oldValue: r }) => t.has(r.id) || o.has(r.id)).map(({ oldValue: r }) => r.id)), w = [
    ...(e.created || []).filter((r) => !f.has(r.id)).map((r) => y.has(r.id) ? n.updated.find(({ oldValue: E }) => E.id === r.id).newValue : r),
    ...n.created || []
  ], g = [
    ...(e.deleted || []).filter((r) => !i.has(r.id)),
    ...(n.deleted || []).filter((r) => !t.has(r.id))
  ], S = [
    ...(e.updated || []).filter(({ newValue: r }) => !f.has(r.id)).map((r) => {
      const { oldValue: E, newValue: A } = r;
      if (y.has(A.id)) {
        const v = n.updated.find((L) => L.oldValue.id === A.id).newValue;
        return J(E, v);
      } else
        return r;
    }),
    ...(n.updated || []).filter(({ oldValue: r }) => !b.has(r.id))
  ];
  return { created: w, deleted: g, updated: S };
}, V = (e) => {
  const n = e.id === void 0 ? F() : e.id;
  return {
    ...e,
    id: n,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((t) => ({
      ...t,
      annotation: n
    })),
    target: {
      ...e.target,
      annotation: n
    }
  };
}, le = (e) => e.id !== void 0, Re = () => {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), t = [], o = (d, c = {}) => {
    t.push({ onChange: d, options: c });
  }, i = (d) => {
    const c = t.findIndex((l) => l.onChange == d);
    c > -1 && t.splice(c, 1);
  }, f = (d, c) => {
    const l = {
      origin: d,
      changes: {
        created: c.created || [],
        updated: c.updated || [],
        deleted: c.deleted || []
      },
      state: [...e.values()]
    };
    t.forEach((p) => {
      re(p, l) && p.onChange(l);
    });
  }, y = (d, c = T.LOCAL) => {
    if (d.id && e.get(d.id))
      throw Error(`Cannot add annotation ${d.id} - exists already`);
    {
      const p = V(d);
      e.set(p.id, p), p.bodies.forEach((U) => n.set(U.id, p.id)), f(c, { created: [p] });
    }
  }, b = (d, c) => {
    const l = V(typeof d == "string" ? c : d), p = typeof d == "string" ? d : d.id, U = p && e.get(p);
    if (U) {
      const C = J(U, l);
      return p === l.id ? e.set(p, l) : (e.delete(p), e.set(l.id, l)), U.bodies.forEach((B) => n.delete(B.id)), l.bodies.forEach((B) => n.set(B.id, l.id)), C;
    } else
      console.warn(`Cannot update annotation ${p} - does not exist`);
  }, w = (d, c = T.LOCAL, l = T.LOCAL) => {
    const p = le(c) ? l : c, U = b(d, c);
    U && f(p, { updated: [U] });
  }, g = (d, c = T.LOCAL) => {
    const l = d.reduce((p, U) => {
      const C = b(U);
      return C ? [...p, C] : p;
    }, []);
    l.length > 0 && f(c, { updated: l });
  }, S = (d, c = T.LOCAL) => {
    const l = e.get(d.annotation);
    if (l) {
      const p = {
        ...l,
        bodies: [...l.bodies, d]
      };
      e.set(l.id, p), n.set(d.id, p.id), f(c, { updated: [{
        oldValue: l,
        newValue: p,
        bodiesCreated: [d]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${d.annotation}`);
  }, r = () => [...e.values()], E = (d = T.LOCAL) => {
    const c = [...e.values()];
    e.clear(), n.clear(), f(d, { deleted: c });
  }, A = (d, c = !0, l = T.LOCAL) => {
    const p = d.map(V);
    if (c) {
      const U = [...e.values()];
      e.clear(), n.clear(), p.forEach((C) => {
        e.set(C.id, C), C.bodies.forEach((B) => n.set(B.id, C.id));
      }), f(l, { created: p, deleted: U });
    } else {
      const U = d.reduce((C, B) => {
        const W = B.id && e.get(B.id);
        return W ? [...C, W] : C;
      }, []);
      if (U.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${U.map((C) => C.id).join(", ")}`);
      p.forEach((C) => {
        e.set(C.id, C), C.bodies.forEach((B) => n.set(B.id, C.id));
      }), f(l, { created: p });
    }
  }, v = (d) => {
    const c = typeof d == "string" ? d : d.id, l = e.get(c);
    if (l)
      return e.delete(c), l.bodies.forEach((p) => n.delete(p.id)), l;
    console.warn(`Attempt to delete missing annotation: ${c}`);
  }, L = (d, c = T.LOCAL) => {
    const l = v(d);
    l && f(c, { deleted: [l] });
  }, O = (d, c = T.LOCAL) => {
    const l = d.reduce((p, U) => {
      const C = v(U);
      return C ? [...p, C] : p;
    }, []);
    l.length > 0 && f(c, { deleted: l });
  }, a = (d) => {
    const c = e.get(d.annotation);
    if (c) {
      const l = c.bodies.find((p) => p.id === d.id);
      if (l) {
        n.delete(l.id);
        const p = {
          ...c,
          bodies: c.bodies.filter((C) => C.id !== d.id)
        };
        return e.set(c.id, p), {
          oldValue: c,
          newValue: p,
          bodiesDeleted: [l]
        };
      } else
        console.warn(`Attempt to delete missing body ${d.id} from annotation ${d.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${d.annotation}`);
  }, u = (d, c = T.LOCAL) => {
    const l = a(d);
    l && f(c, { updated: [l] });
  }, s = (d, c = T.LOCAL) => {
    const l = d.map((p) => a(p)).filter(Boolean);
    l.length > 0 && f(c, { updated: l });
  }, h = (d) => {
    const c = e.get(d);
    return c ? { ...c } : void 0;
  }, m = (d) => {
    const c = n.get(d);
    if (c) {
      const p = h(c).bodies.find((U) => U.id === d);
      if (p)
        return p;
      console.error(`Store integrity error: body ${d} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${d}`);
  }, R = (d, c) => {
    if (d.annotation !== c.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const l = e.get(d.annotation);
    if (l) {
      const p = l.bodies.find((C) => C.id === d.id), U = {
        ...l,
        bodies: l.bodies.map((C) => C.id === p.id ? c : C)
      };
      return e.set(l.id, U), p.id !== c.id && (n.delete(p.id), n.set(c.id, U.id)), {
        oldValue: l,
        newValue: U,
        bodiesUpdated: [{ oldBody: p, newBody: c }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${d.annotation}`);
  }, N = (d, c, l = T.LOCAL) => {
    const p = R(d, c);
    p && f(l, { updated: [p] });
  }, x = (d, c = T.LOCAL) => {
    const l = d.map((p) => R({ id: p.id, annotation: p.annotation }, p)).filter(Boolean);
    f(c, { updated: l });
  }, P = (d) => {
    const c = e.get(d.annotation);
    if (c) {
      const l = {
        ...c,
        target: {
          ...c.target,
          ...d
        }
      };
      return e.set(c.id, l), {
        oldValue: c,
        newValue: l,
        targetUpdated: {
          oldTarget: c.target,
          newTarget: d
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${d.annotation}`);
  };
  return {
    addAnnotation: y,
    addBody: S,
    all: r,
    bulkAddAnnotation: A,
    bulkDeleteAnnotation: O,
    bulkDeleteBodies: s,
    bulkUpdateAnnotation: g,
    bulkUpdateBodies: x,
    bulkUpdateTargets: (d, c = T.LOCAL) => {
      const l = d.map((p) => P(p)).filter(Boolean);
      l.length > 0 && f(c, { updated: l });
    },
    clear: E,
    deleteAnnotation: L,
    deleteBody: u,
    getAnnotation: h,
    getBody: m,
    observe: o,
    unobserve: i,
    updateAnnotation: w,
    updateBody: N,
    updateTarget: (d, c = T.LOCAL) => {
      const l = P(d);
      l && f(c, { updated: [l] });
    }
  };
}, Be = (e) => ({
  ...e,
  subscribe: (t) => {
    const o = (i) => t(i.state);
    return e.observe(o), t(e.all()), () => e.unobserve(o);
  }
});
let Q = () => ({
  emit(e, ...n) {
    for (let t = 0, o = this.events[e] || [], i = o.length; t < i; t++)
      o[t](...n);
  },
  events: {},
  on(e, n) {
    var t;
    return ((t = this.events)[e] || (t[e] = [])).push(n), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => n !== i);
    };
  }
});
const ue = 250, Ie = (e) => {
  const n = Q(), t = [];
  let o = -1, i = !1, f = 0;
  const y = (s) => {
    if (!i) {
      const { changes: h } = s, m = performance.now();
      if (m - f > ue)
        t.splice(o + 1), t.push(h), o = t.length - 1;
      else {
        const R = t.length - 1;
        t[R] = ce(t[R], h);
      }
      f = m;
    }
    i = !1;
  };
  e.observe(y, { origin: T.LOCAL });
  const b = (s) => s && s.length > 0 && e.bulkDeleteAnnotation(s), w = (s) => s && s.length > 0 && e.bulkAddAnnotation(s, !1), g = (s) => s && s.length > 0 && e.bulkUpdateAnnotation(s.map(({ oldValue: h }) => h)), S = (s) => s && s.length > 0 && e.bulkUpdateAnnotation(s.map(({ newValue: h }) => h)), r = (s) => s && s.length > 0 && e.bulkAddAnnotation(s, !1), E = (s) => s && s.length > 0 && e.bulkDeleteAnnotation(s);
  return {
    canRedo: () => t.length - 1 > o,
    canUndo: () => o > -1,
    destroy: () => e.unobserve(y),
    on: (s, h) => n.on(s, h),
    redo: () => {
      if (t.length - 1 > o) {
        i = !0;
        const { created: s, updated: h, deleted: m } = t[o + 1];
        w(s), S(h), E(m), n.emit("redo", t[o + 1]), o += 1;
      }
    },
    undo: () => {
      if (o > -1) {
        i = !0;
        const { created: s, updated: h, deleted: m } = t[o];
        b(s), g(h), r(m), n.emit("undo", t[o]), o -= 1;
      }
    }
  };
}, xe = () => {
  const { subscribe: e, set: n } = M([]);
  return {
    subscribe: e,
    set: n
  };
}, ke = (e, n, t, o) => {
  const { store: i, selection: f, hover: y, viewport: b } = e, w = /* @__PURE__ */ new Map();
  let g = [], S, r;
  const E = (a, u) => {
    w.has(a) ? w.get(a).push(u) : w.set(a, [u]);
  }, A = (a, u) => {
    const s = w.get(a);
    if (s) {
      const h = s.indexOf(u);
      h !== -1 && s.splice(h, 1);
    }
  }, v = (a, u, s) => {
    w.has(a) && setTimeout(() => {
      w.get(a).forEach((h) => {
        if (t) {
          const m = Array.isArray(u) ? u.map((N) => t.serialize(N)) : t.serialize(u), R = s ? s instanceof PointerEvent ? s : t.serialize(s) : void 0;
          h(m, R);
        } else
          h(u, s);
      });
    }, 1);
  }, L = () => {
    const { selected: a } = f, u = (a || []).map(({ id: s }) => i.getAnnotation(s));
    u.forEach((s) => {
      const h = g.find((m) => m.id === s.id);
      (!h || !I(h, s)) && v("updateAnnotation", s, h);
    }), g = g.map((s) => {
      const h = u.find(({ id: m }) => m === s.id);
      return h || s;
    });
  };
  f.subscribe(({ selected: a }) => {
    if (!(g.length === 0 && a.length === 0)) {
      if (g.length === 0 && a.length > 0)
        g = a.map(({ id: u }) => i.getAnnotation(u));
      else if (g.length > 0 && a.length === 0)
        g.forEach((u) => {
          const s = i.getAnnotation(u.id);
          s && !I(s, u) && v("updateAnnotation", s, u);
        }), g = [];
      else {
        const u = new Set(g.map((m) => m.id)), s = new Set(a.map(({ id: m }) => m));
        g.filter((m) => !s.has(m.id)).forEach((m) => {
          const R = i.getAnnotation(m.id);
          R && !I(R, m) && v("updateAnnotation", R, m);
        }), g = [
          // Remove annotations that were deselected
          ...g.filter((m) => s.has(m.id)),
          // Add editable annotations that were selected
          ...a.filter(({ id: m }) => !u.has(m)).map(({ id: m }) => i.getAnnotation(m))
        ];
      }
      v("selectionChanged", g);
    }
  }), y.subscribe((a) => {
    !S && a ? v("mouseEnterAnnotation", i.getAnnotation(a)) : S && !a ? v("mouseLeaveAnnotation", i.getAnnotation(S)) : S && a && (v("mouseLeaveAnnotation", i.getAnnotation(S)), v("mouseEnterAnnotation", i.getAnnotation(a))), S = a;
  }), b == null || b.subscribe((a) => v("viewportIntersect", a.map((u) => i.getAnnotation(u)))), i.observe((a) => {
    o && (r && clearTimeout(r), r = setTimeout(L, 1e3));
    const { created: u, deleted: s } = a.changes;
    (u || []).forEach((m) => v("createAnnotation", m)), (s || []).forEach((m) => v("deleteAnnotation", m)), (a.changes.updated || []).filter((m) => [
      ...m.bodiesCreated || [],
      ...m.bodiesDeleted || [],
      ...m.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: m, newValue: R }) => {
      const N = g.find((x) => x.id === m.id) || m;
      g = g.map((x) => x.id === m.id ? R : x), v("updateAnnotation", R, N);
    });
  }, { origin: T.LOCAL }), i.observe((a) => {
    if (g) {
      const u = new Set(g.map((h) => h.id)), s = (a.changes.updated || []).filter(({ newValue: h }) => u.has(h.id)).map(({ newValue: h }) => h);
      s.length > 0 && (g = g.map((h) => {
        const m = s.find((R) => R.id === h.id);
        return m || h;
      }));
    }
  }, { origin: T.REMOTE });
  const O = (a) => (u) => {
    const { updated: s } = u;
    a ? (s || []).forEach((h) => v("updateAnnotation", h.oldValue, h.newValue)) : (s || []).forEach((h) => v("updateAnnotation", h.newValue, h.oldValue));
  };
  return n.on("undo", O(!0)), n.on("redo", O(!1)), { on: E, off: A, emit: v };
}, Ne = (e) => (n) => n.map((t) => e.serialize(t)), fe = (e) => (n) => n.reduce((t, o) => {
  const { parsed: i, error: f } = e.parse(o);
  return f ? {
    parsed: t.parsed,
    failed: [...t.failed, o]
  } : i ? {
    parsed: [...t.parsed, i],
    failed: t.failed
  } : {
    ...t
  };
}, { parsed: [], failed: [] }), ze = (e, n, t) => {
  const { store: o, selection: i } = e, f = (a) => {
    if (t) {
      const { parsed: u, error: s } = t.parse(a);
      u ? o.addAnnotation(u, T.REMOTE) : console.error(s);
    } else
      o.addAnnotation(j(a), T.REMOTE);
  }, y = () => i.clear(), b = () => o.clear(), w = (a) => {
    const u = o.getAnnotation(a);
    return t && u ? t.serialize(u) : u;
  }, g = () => t ? o.all().map(t.serialize) : o.all(), S = () => {
    var s;
    const u = (((s = i.selected) == null ? void 0 : s.map((h) => h.id)) || []).map((h) => o.getAnnotation(h)).filter(Boolean);
    return t ? u.map(t.serialize) : u;
  }, r = (a, u = !0) => fetch(a).then((s) => s.json()).then((s) => (A(s, u), s)), E = (a) => {
    if (typeof a == "string") {
      const u = o.getAnnotation(a);
      if (o.deleteAnnotation(a), u)
        return t ? t.serialize(u) : u;
    } else {
      const u = t ? t.parse(a).parsed : a;
      if (u)
        return o.deleteAnnotation(u), a;
    }
  }, A = (a, u = !0) => {
    if (t) {
      const s = t.parseAll || fe(t), { parsed: h, failed: m } = s(a);
      m.length > 0 && console.warn(`Discarded ${m.length} invalid annotations`, m), o.bulkAddAnnotation(h, u, T.REMOTE);
    } else
      o.bulkAddAnnotation(a.map(j), u, T.REMOTE);
  }, v = (a, u) => {
    a ? i.setSelected(a, u) : i.clear();
  }, L = (a) => {
    i.clear(), i.setUserSelectAction(a);
  }, O = (a) => {
    if (t) {
      const u = t.parse(a).parsed, s = t.serialize(o.getAnnotation(u.id));
      return o.updateAnnotation(u), s;
    } else {
      const u = o.getAnnotation(a.id);
      return o.updateAnnotation(j(a)), u;
    }
  };
  return {
    addAnnotation: f,
    cancelSelected: y,
    canRedo: n.canRedo,
    canUndo: n.canUndo,
    clearAnnotations: b,
    getAnnotationById: w,
    getAnnotations: g,
    getSelected: S,
    loadAnnotations: r,
    redo: n.redo,
    removeAnnotation: E,
    setAnnotations: A,
    setSelected: v,
    setUserSelectAction: L,
    undo: n.undo,
    updateAnnotation: O
  };
}, pe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let ge = (e) => crypto.getRandomValues(new Uint8Array(e)), he = (e, n, t) => {
  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * n / e.length);
  return (f = n) => {
    let y = "";
    for (; ; ) {
      let b = t(i), w = i;
      for (; w--; )
        if (y += e[b[w] & o] || "", y.length === f) return y;
    }
  };
}, me = (e, n = 21) => he(e, n, ge), Ae = (e = 21) => {
  let n = "", t = crypto.getRandomValues(new Uint8Array(e));
  for (; e--; )
    n += pe[t[e] & 63];
  return n;
};
const $e = () => ({ isGuest: !0, id: me("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), be = (e) => {
  const n = JSON.stringify(e);
  let t = 0;
  for (let o = 0, i = n.length; o < i; o++) {
    let f = n.charCodeAt(o);
    t = (t << 5) - t + f, t |= 0;
  }
  return `${t}`;
}, ve = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, Ve = (e, n) => (Array.isArray(e) ? e : [e]).map((t) => {
  const { id: o, type: i, purpose: f, value: y, created: b, modified: w, creator: g, ...S } = t;
  return {
    id: o || `temp-${be(t)}`,
    annotation: n,
    type: i,
    purpose: f,
    value: y,
    creator: ve(g),
    created: b ? new Date(b) : void 0,
    updated: w ? new Date(w) : void 0,
    ...S
  };
}), _e = (e) => e.map((n) => {
  var b;
  const { annotation: t, created: o, updated: i, ...f } = n, y = {
    ...f,
    created: o == null ? void 0 : o.toISOString(),
    modified: i == null ? void 0 : i.toISOString()
  };
  return (b = y.id) != null && b.startsWith("temp-") && delete y.id, y;
}), Ee = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], we = () => {
  const e = [...Ee];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), i = e[o];
    return e.splice(o, 1), i;
  }, releaseColor: (o) => e.push(o) };
}, ye = () => {
  const e = we();
  return { addUser: (o, i) => {
    const f = e.assignRandomColor();
    return {
      label: i.name || i.id,
      avatar: i.avatar,
      color: f
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
}, Ce = (e, n) => e.every((t) => e.includes(t)) && n.every((t) => e.includes(t)), Ye = Ae(), je = (e = ye()) => {
  const n = Q(), t = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = (r, E) => {
    if (t.has(r)) {
      console.warn("Attempt to add user that is already present", r, E);
      return;
    }
    const A = e.addUser(r, E);
    t.set(r, {
      ...E,
      presenceKey: r,
      appearance: A
    });
  }, f = (r) => {
    const E = t.get(r);
    if (!E) {
      console.warn("Attempt to remove user that is not present", r);
      return;
    }
    e.removeUser(E), t.delete(r);
  }, y = (r) => {
    const E = new Set(r.map((L) => L.presenceKey)), A = r.filter(({ presenceKey: L }) => !t.has(L)), v = Array.from(t.values()).filter((L) => !E.has(L.presenceKey));
    A.forEach(({ presenceKey: L, user: O }) => i(L, O)), v.forEach((L) => {
      const { presenceKey: O } = L;
      o.has(O) && n.emit("selectionChange", L, null), f(O);
    }), (A.length > 0 || v.length > 0) && n.emit("presence", g());
  }, b = (r, E) => {
    const A = t.get(r);
    if (!A) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const v = o.get(r);
    (!v || !Ce(v, E)) && (o.set(r, E), n.emit("selectionChange", A, E));
  }, w = (r, E) => {
    const A = t.get(r);
    if (!A) {
      console.warn("Selection change for user that is not present", r);
      return;
    }
    E ? o.set(r, E) : o.delete(r), n.emit("selectionChange", A, E);
  }, g = () => [...Array.from(t.values())];
  return {
    getPresentUsers: g,
    notifyActivity: b,
    on: (r, E) => n.on(r, E),
    syncUsers: y,
    updateSelection: w
  };
};
export {
  ae as Ignore,
  T as Origin,
  Ye as PRESENCE_KEY,
  Z as UserSelectAction,
  $e as createAnonymousGuest,
  ze as createBaseAnnotator,
  De as createBody,
  ye as createDefaultAppearanceProvider,
  Ue as createHoverState,
  ke as createLifecycleObserver,
  je as createPresenceState,
  Te as createSelectionState,
  Re as createStore,
  Ie as createUndoStack,
  xe as createViewportState,
  we as defaultColorProvider,
  J as diffAnnotations,
  Oe as getContributors,
  ce as mergeChanges,
  G as onUserSelect,
  fe as parseAll,
  Ve as parseW3CBodies,
  ve as parseW3CUser,
  j as reviveDates,
  Ne as serializeAll,
  _e as serializeW3CBodies,
  re as shouldNotify,
  Be as toSvelteStore
};
//# sourceMappingURL=annotorious-core.es.js.map
